Поиск в ширину (обход в ширину, breadth-first search) — это один из основных алгоритмов на графах.
В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий наименьшее число рёбер.
Алгоритм работает за O (n+m), где n — число вершин, m — число рёбер.
На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины s.
Граф может быть как ориентированным, так и неориентированным, для алгоритма это не важно.
Сам алгоритм можно понимать как процесс "поджигания" графа: на нулевом шаге поджигаем только вершину s.
На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей;
т.е. за одну итерацию алгоритма происходит расширение "кольца огня" в ширину на единицу (отсюда и название алгоритма).
Более строго это можно представить следующим образом.
Создадим очередь q, в которую будут помещаться горящие вершины, а также заведём булевский массив \rm used[], в котором для каждой вершины будем отмечать,
горит она уже или нет (или иными словами, была ли она посещена).
Изначально в очередь помещается только вершина s, и \rm used[s] = true, а для всех остальных вершин \rm used[] = false.
Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все рёбра,
исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и поместить в конец очереди.
В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из s вершины, причём до каждой дойдёт кратчайшим путём.
Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей d[]),
и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести массив "предков" p[],
в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).




...BACKUP...
adjustments = [
    # список смежности\связности
    [1, 3],  # 0
    [0, 3, 4, 5],  # 1
    [4, 5],  # 2
    [0, 1, 5],  # 31
    [1, 2],  # 4
    [1, 2, 3]  # 5
]

# список вершин (изначально = -1, т.к не пройдены), в дальнейшем список кратчайших путей
vertex = [-1] * len(adjustments)

# Breadth-first search (Поиск в ширину)


def bfs(startPoint):
    global vertex
    vertex[startPoint] = 0  # проходим вершину s как начальную
    queue = list()  # очередь для поиска
    queue.append(startPoint)  # добавляем начальную вершину в очередь
    while queue:
        level = queue.pop(0)
        for point in adjustments[level]:  # запускаем обход из вершины level
            if vertex[point] == -1:  # проверка на посещенность
                queue.append(point)  # добавление вершины в очередь
                vertex[point] = vertex[level] + 1  # подсчитываем уровень вершины


bfs(int(input('Введите номер вершины: ')))
print(f'\nКратчайшие пути: {vertex}')  # №1

components = list()  # список компонент связности
for index in range(len(adjustments)):
    # подсчет количества вершин в компоненте
    components.append(len(adjustments[index]))
print(f'\nКоличество компонент: {components}')  # №2